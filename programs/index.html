---
layout: default
title: Programs - OSIsoft Engineering Organization
---
<head>
	<style>
img {
    display: block;
    margin-left: auto;
    margin-right: auto;
}
</style>
</head>

<div class="blurb">
	<h1>Engineering Programs</h1>
	
	<p>The lifecycle for a typical product or service is shown in Figure 1 below. The green line represents the revenue generated by the product or service and the red line represents the development and support costs. For our purpose we’ll talk specifically about products, but the same arguments also hold true for service.</p>
	<img src="/images/Program_Figure1.PNG" style="width:50%;">
	<p>A typical product will move through 4 phases: Introduction, Growth, Maturity, and Decline. The time a product will spend in any one phase can depend on any number of factors both internal and external. We typically want to extend the time a product spends in the growth or maturity phases as these are the optimal revenue generating periods. This desire must be balanced with the development costs at any point in the cycle. As shown, it is difficult to make data driven decisions early in the product phase as most revenue is realized well after the major cost has been incurred. In most cases we need to rely on market analyses and predictive models to help with funding decisions. </p>
	
<p>The example above depicts a somewhat ideal scenario where the cost sharply drops off as the product approaches maturity, but this is rarely the reality. The example also depicts costs stabilizing at a low level over time. As a product enters the decline phase the recurring cost should be modeled to predict when revenue no longer exceeds cost. In some cases, it may be worth investing more in development as a product enters this phase to lower the eventual recurring costs in the decline phase.</p>

<p>The longer a product remains in use, the higher the likelihood that significant investments must be made to keep the product viable. Typical causes include the release of a new operating system or new security requirements that apply to the product or target market. A large cost may also appear at the tail end of the lifecycle if a product migration is required. </p>

<p>There are several strategies to extending the viable life of a product and the most common is to reinvest in features and capabilities. An example of this behavior is depicted in Figure 2. The underlying assumption is that the cost of adding incremental capabilities is far cheaper than creating a completely new offering. Although this approach can be very successful it’s also commonly observed that the costs associated with adding incremental features over time increases. At a certain point in the product's lifecycle it is no longer efficient to continue with the original codebase and a major reinvestment must occur. </p>

  </br>

<img src="/images/Program_Figure2.PNG" style="width:50%;">

</br>
<p>There are many factors that should influence the choice to reinvest or not. It doesn’t make much sense to invest in new capabilities if there is no potential revenue but it’s also common to see time lag between feature engineering and revenue. This means that we cannot solely rely on revenue numbers to set product direction. Another factor to account for is that once a product is defunded it can be very expensive to restart. If the time window is short this could just be a matter of reassigning the original team back to the effort; if it’s a longer window this could require retraining an entirely new team.</p>

<p>Thus, it is reasonable to assert that when a product is funded, it should be to deliver major new capabilities. These capabilities should be linked to end user scenarios which have been determined to have monetary value. This is as true for a new product as an incremental investment. </p>

<p>It is proposed that we term these major funding events as Engineering Programs. The attributes of a Program are: 
<ul>
<li>A Program should execute over a fixed period based on the time required to deliver major capabilities which address specific market problems. </li>
<li>Multiple Programs may be funded in succession over the initial life cycle of a product. </li>
<li>Each Program will result in a complete product which can enter a decline phase without significant recurring costs. </li>
</ul>

<h1>Program Organization</h1>
<p>The complexity of any software system increases over time and it becomes increasingly challenging to efficiently solve new problems. As the system grows we need to balance local decision making with the ability to deliver a consistent and manageable system. As with computing, we know we can gain efficiency by running tasks in parallel, but the overall speedup is limited by any purely sequential processes. To this end, we strive to create small and autonomous teams that are free to get work done without rate limiting dependencies external to the team. These teams become Development’s core unit of scalability and the rest of the department's focus turns to providing whatever guidance is necessary to target these teams at high value outcomes. </p>
<p>Once stable, a typical development team will compromise of Team Lead and between 4 and 8 developers. It is assumed that teams are stable constructs and that the individuals on the team grow and evolve skills and competencies over time. This is not to say that problems a team works on or the codebase they contribute to are stable over time. We want to avoid create ownership over a code base or problem domains as it can create perverse incentives that we want to avoid. Ultimately, we hire smart individuals and if we align them with business goals they’ll be able to deliver great results, even autonomously.  </p>
</br>
<img src="/images/Program_Figure3.PNG" style="width:30%;">
</br>
<p>In this context, we can look at a Program as a mechanism to organize around a business goal. If we can break down a Program’s overall objective into distinct components, then we can leverage multiple teams to execute on the goals in parallel. A diverse set of support functions are required in order to successfully execute a Program. Some of these skills are required fulltime for the extent of the Program and some are only necessary at certain junctures. Also, different Programs will have different needs depending on the deliverable, therefore composition may vary from Program to Program. Essentially, Programs enable the department to successfully execute on problems of a larger scope and of higher value than possible with an individual team.  </p>

<img src="/images/Program_Figure4.PNG" style="width:50%;">

<p>The charts in Figure 4 provide a basis for a conceptual budget for the department. As with any budget, the goal is to provide a basis for balancing resources and identifying needs. One thing that is apparent is that we need to grow the program support functions significantly.  </p>

<h2>Guilds</h2>
<p>As we grow these functions, there will be a need to develop best practices and consistency within specialized roles. We will refer to these functional teams as Guilds to differentiate them from Development Teams. </p>

<img src="/images/Program_Figure5.PNG" style="width:60%;">
<p>The graphic in Figure 4 depicts the relationship between Guilds, Teams and Programs. A Program consists of one or more Teams, plus representation from most if not all Guilds. The number of teams involved in a Program may vary as will the composition of program support functions from Guilds. It’s also possible that a development team would have goals described under multiple Programs. Although technically possible, we would typically try to avoid this situation, as balancing priorities can be difficult. </p>

<h2>Working with Conway's Law</h2>
<p><center><em>Any organization that designs a system… will produce a design whose structure is a copy of the organization's communication structure.</em></center></p>

<p>One of the common challenges with organization design for a generative discipline is understanding how Conway’s law may affect the product and whether that influence is positive or negative. For complex efforts it’s natural to try to align authority with outcomes in order to reinforce priority but this is commonly counterproductive. </p>

<p>Guilds provide a multi-faceted approach to leadership shaped by the needs of the Program not by the flow of authority. For example, the Leadership guild is tasked with providing coaching, recruiting and administrative support to teams and as such doesn’t strongly influence the scope or priorities of a Program. In cases where a Program spans offices it makes sense for the teams to report to a local member of a Leadership guild. In contrast, the Program Management guild is focused on the execution of the program and as such has direct influence over all teams in a Program. </p>
